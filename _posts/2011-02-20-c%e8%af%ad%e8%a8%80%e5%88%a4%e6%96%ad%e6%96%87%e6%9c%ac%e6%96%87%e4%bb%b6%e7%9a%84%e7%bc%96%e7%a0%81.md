--- 
date: 2011-02-20 20:13:00 +08:00
layout: post
title: !binary |
    Q+ivreiogOWIpOaWreaWh+acrOaWh+S7tueahOe8lueggQ==

wordpress_id: 710
wordpress_url: !binary |
    aHR0cDovL3d3dy50b2J5Y24ub3JnLzIwMTEvMDIvJWU2JWFmJTgxJWU2JThl
    JTg5JWU0JWI4JTgwJWU0JWI4JWFhJWU1JWFkJWE5JWU1JWFkJTkwJWU3JTlh
    JTg0JWU1JTg3JWEwJWU0JWI4JWFhJWU3JWFlJTgwJWU1JThkJTk1JWU2JTk2
    JWI5JWU2JWIzJTk1JWVmJWJjJTg4JWU4JWJkJWFjJWVmJWJjJTg5Lmh0bWw=

---
不同编码的文本，是根据文本的前两个字节来定义其编码格式的。定义如下：

ANSI：　　　　　　　　无格式定义；
Unicode： 　　　　　　前两个字节为FFFE；
Unicode big endian：　前两字节为FEFF；
UTF-8：　 　　　　　　前两字节为EFBB；
-- 以上是在网上找到的内容，没再仔细找，比如GB2312/GB18030等，不过原理应该是一样的吧

以下是我写的一段测试用的代码


#include 
int main(int argc, char *argv[])
{
FILE *f;
unsigned char code[2];
short rlen = 0;
if (argc &lt; = 1) { printf(" Usage: %s filename [ filename2 [...]]", argv[0]); return -1; } for ( ; --argc &gt; 0; ) {
f = fopen(*++argv, "rb");
if (f) {
rlen = fread(code, 1, 2, f);
if(rlen == 2) {
if (code[0]==0xEF &amp;&amp; code[1]==0xBB) {
printf("%s encode UTF-8n", *argv);
}else if(code[0]==0xFF &amp;&amp; code[1]==0xFE) {
printf("%s encode Unicoden", *argv);
}else if(code[0]==0xFE &amp;&amp; code[1]==0xFF) {
printf("%s encode Unicode Big Endliann", *argv);
}else {
printf("%s encode ASCIIn", *argv);
}
}else {
printf("%s unknow errn", *argv);
}
fclose(f);
}else
printf("%s not existsn", *argv);
}
}
